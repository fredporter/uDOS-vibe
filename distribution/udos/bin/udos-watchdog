#!/bin/sh
# uDOS System Watchdog
# Monitors health and triggers recovery on failures
#
# Strategy:
# 1. Monitor GUI process health (if Tier 2)
# 2. Track crash count + time Windows
# 3. Fallback to TUI on repeated failures
# 4. Log events for diagnostics
# 5. Optional automated recovery actions

set -e

UDOS_CONFIG="/etc/udos"
MODE_FILE="$UDOS_CONFIG/mode"
PERSIST_MOUNT="/mnt/udos"
RECOVERY_LOG="$PERSIST_MOUNT/logs/recovery.log"
CRASH_COUNT_FILE="/var/run/udos-crash-count"
CRASH_THRESHOLD=3
CRASH_WINDOW=600  # 10 minutes

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

info() { echo "[$(date +'%H:%M:%S')] [INFO] $*" | tee -a "$RECOVERY_LOG"; }
warn() { echo "[$(date +'%H:%M:%S')] [WARN] $*" | tee -a "$RECOVERY_LOG"; }
error() { echo "[$(date +'%H:%M:%S')] [ERROR] $*" | tee -a "$RECOVERY_LOG" >&2; }

# Initialize
init_watchdog() {
    mkdir -p "$(dirname "$RECOVERY_LOG")"
    touch "$RECOVERY_LOG"

    info "Watchdog initialized"
    info "Mode file: $MODE_FILE"
    info "Recovery log: $RECOVERY_LOG"
}

# Get current mode
get_mode() {
    if [ -f "$MODE_FILE" ]; then
        cat "$MODE_FILE"
    else
        echo "tui"
    fi
}

# Increment crash count
increment_crash_count() {
    local count=0
    local timestamp=$(date +%s)

    if [ -f "$CRASH_COUNT_FILE" ]; then
        read -r old_count old_time 2>/dev/null <"$CRASH_COUNT_FILE" || true
        local elapsed=$((timestamp - old_time))

        if [ $elapsed -lt $CRASH_WINDOW ]; then
            count=$((old_count + 1))
        else
            # Outside window, reset
            count=1
        fi
    else
        count=1
    fi

    echo "$count $timestamp" >"$CRASH_COUNT_FILE"
    echo "$count"
}

# Reset crash count
reset_crash_count() {
    rm -f "$CRASH_COUNT_FILE"
}

# Get current crash count
get_crash_count() {
    if [ -f "$CRASH_COUNT_FILE" ]; then
        read -r count _ <"$CRASH_COUNT_FILE"
        echo "$count"
    else
        echo "0"
    fi
}

# Monitor GUI process
monitor_gui() {
    local mode=$(get_mode)

    if [ "$mode" != "gui" ]; then
        return 0  # Not in GUI mode, skip monitoring
    fi

    # Check if cage/udos-ui is running
    if ! pgrep -x "cage\|udos-ui" >/dev/null 2>&1; then
        warn "GUI process not running (cage or udos-ui)"
        return 1
    fi

    # Check for zombie processes
    if pgrep -x "cage" | xargs -I {} sh -c 'ps -o state= -p {} | grep -q Z' 2>/dev/null; then
        error "Zombie GUI process detected"
        return 2
    fi

    return 0
}

# Attempt recovery
attempt_recovery() {
    local exit_code=$1
    local crash_count=$(increment_crash_count)

    warn "Recovery triggered (exit code: $exit_code, crashes: $crash_count/$CRASH_THRESHOLD)"

    # Log crash details
    {
        echo "=== Crash $(date) ==="
        echo "Exit code: $exit_code"
        echo "Crash count: $crash_count"
        echo "Mode: $(get_mode)"
        ps aux | head -20
        echo ""
    } >>"$RECOVERY_LOG"

    if [ "$exit_code" -eq 0 ]; then
        # Normal exit - reset crash count
        info "GUI exited normally"
        reset_crash_count
        return 0
    fi

    if [ "$crash_count" -ge "$CRASH_THRESHOLD" ]; then
        # Too many crashes - fallback to TUI
        error "Crash threshold exceeded, falling back to TUI mode"
        fallback_to_tui
        return 1
    fi

    # Single crash - attempt to restart
    warn "Attempting recovery (attempt $crash_count/$CRASH_THRESHOLD)"
    sleep 2
    return 0
}

# Fallback to TUI mode
fallback_to_tui() {
    error "FALLBACK: Switching to TUI mode due to repeated GUI crashes"

    # Write fallback event
    {
        echo ""
        echo "=== FALLBACK TO TUI $(date) ==="
        echo "Reason: Repeated GUI failures"
        echo "Previous crashes: $(get_crash_count)"
        echo "System will restart in TUI mode"
        echo ""
    } >>"$RECOVERY_LOG"

    # Switch mode
    echo "tui" >"$MODE_FILE"
    reset_crash_count

    # Kill GUI services
    rc-service udos-gui stop 2>/dev/null || true

    # Stop cage if still running
    pkill -TERM cage 2>/dev/null || true

    # Return to TTY (or reboot)
    # For now, just log the recovery
    warn "System ready for TUI restart"
}

# Monitor volume/disk space
check_disk_health() {
    if ! mountpoint -q "$PERSIST_MOUNT"; then
        error "Persistence partition unmounted - recovery may fail"
        return 1
    fi

    local usage=$(df "$PERSIST_MOUNT" | tail -1 | awk '{print $5}' | sed 's/%//')
    if [ "$usage" -gt 95 ]; then
        error "Persistence partition is $usage% full - this may cause GUI crashes"
        return 1
    fi

    return 0
}

# Main watchdog loop
watchdog_loop() {
    init_watchdog

    while true; do
        # Check system health
        if ! check_disk_health; then
            warn "Disk health check failed"
        fi

        # Monitor GUI if enabled
        if [ "$(get_mode)" = "gui" ]; then
            if ! monitor_gui; then
                attempt_recovery $?
            fi
        fi

        # Sleep before next check
        sleep 10
    done
}

# Health diagnostics
cmd_diagnostics() {
    cat <<EOF
╭─ uDOS System Diagnostics ──────────────────────────────╮
│                                                          │
│  Current Mode: $(get_mode)
│  Crash Count: $(get_crash_count)/$CRASH_THRESHOLD
│  Last Crash: $(tail -1 "$CRASH_COUNT_FILE" 2>/dev/null | awk '{print $2}' | xargs date -d @)
│                                                          │
│  Persistence: $(mountpoint -q "$PERSIST_MOUNT" && echo "MOUNTED" || echo "NOT MOUNTED")
│  Disk Usage: $(df "$PERSIST_MOUNT" 2>/dev/null | tail -1 | awk '{print $5}')
│  Log File: $RECOVERY_LOG
│                                                          │
│  GUI Status:                                            │
│  - Cage: $(pgrep -x cage >/dev/null 2>&1 && echo "RUNNING" || echo "STOPPED")
│  - udos-ui: $(pgrep -x udos-ui >/dev/null 2>&1 && echo "RUNNING" || echo "STOPPED")
│  - seatd: $(pgrep -x seatd >/dev/null 2>&1 && echo "RUNNING" || echo "STOPPED")
│                                                          │
╰──────────────────────────────────────────────────────────╯

Recent crashes (last 20 lines of recovery log):
$(tail -20 "$RECOVERY_LOG" 2>/dev/null || echo "[No crash history]")
EOF
}

# Show help
cmd_help() {
    cat <<'EOF'
udos-watchdog - uDOS System Watchdog & Recovery Manager

The watchdog monitors system health and provides automatic recovery:
- Detects GUI process crashes
- Tracks crash count within time windows
- Falls back to TUI on repeated failures
- Logs all recovery events

Usage (typically run as OpenRC service):
  rc-service udos-watchdog start
  rc-service udos-watchdog stop
  rc-service udos-watchdog status

Manual invocation:
  udos-watchdog run          Run watchdog loop (foreground)
  udos-watchdog diagnostics  Show system health report
  udos-watchdog help         This help message

Configuration:
  Mode file:        /etc/udos/mode
  Recovery log:     /mnt/udos/logs/recovery.log
  Crash threshold:  3 crashes within 10 minutes
  Fallback action:  Switch to TUI mode

Crash Handling:
  - Crash #1-2:  Automatic restart attempt
  - Crash #3:    Fallback to TUI mode
  - Exit code 0: Normal - reset crash counter

Log Files:
  /var/log/messages          - System log
  /mnt/udos/logs/recovery.log - Recovery events
  /var/run/udos-crash-count   - Current crash tracking

Examples:
  $ rc-service udos-watchdog start
  $ udos-watchdog diagnostics
  $ tail -f /mnt/udos/logs/recovery.log
EOF
}

# Entry point
case "${1:-run}" in
    run)
        watchdog_loop
        ;;
    diagnostics)
        cmd_diagnostics
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
