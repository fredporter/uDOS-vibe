#!/bin/sh
# uDOS Alpine Core GUI Launcher
# Wayland + Cage + Tauri single-app session management
#
# Responsibilities:
# - Ensure persistence mount exists
# - Export Wayland environment variables
# - Manage seatd lifecycle
# - Launch Cage with udos-ui
# - Handle exit behavior
#
# Usage: udos-gui [start|stop|restart]

set -eu

# Configuration
UDOS_PERSIST="${UDOS_PERSIST:-/mnt/udos}"
UDOS_CONFIG="${UDOS_CONFIG:-/etc/udos}"
UDOS_LOG="${UDOS_LOG:-$UDOS_PERSIST/logs}"
UDOS_UI_BIN="${UDOS_UI_BIN:-/usr/local/bin/udos-ui}"
UDOS_UI_STATE="${UDOS_UI_STATE:-/var/udos/ui}"
WAYLAND_DISPLAY="wayland-0"
XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/1000}"

# ANSI color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [INFO] $*" | tee -a "$UDOS_LOG/udos-gui.log"
}

log_error() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [ERROR] $*" | tee -a "$UDOS_LOG/udos-gui.log" >&2
}

log_warn() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [WARN] $*" | tee -a "$UDOS_LOG/udos-gui.log"
}

# Ensure bind mount from persistence to rootfs
ensure_bind_mount() {
    local target="$1"
    local source="$2"

    if [ -L "$target" ]; then
        if [ "$(readlink "$target")" = "$source" ]; then
            return 0
        fi
        log_warn "Replacing symlink at $target with bind mount from $source"
        rm -f "$target"
    fi

    if [ -f "$target" ]; then
        log_error "Cannot bind mount over file: $target"
        return 1
    fi

    mkdir -p "$target"

    if mountpoint -q "$target" 2>/dev/null; then
        return 0
    fi

    log_info "Bind mounting $source -> $target"
    if ! mount --bind "$source" "$target"; then
        log_error "Bind mount failed: $source -> $target"
        return 1
    fi

    return 0
}

# Ensure persistence mount exists
ensure_persistence() {
    if [ ! -d "$UDOS_PERSIST" ]; then
        log_error "Persistence mount not found: $UDOS_PERSIST"
        log_error "Mount UDOS_PERSIST partition before starting GUI mode"
        return 1
    fi

    if ! mountpoint -q "$UDOS_PERSIST" 2>/dev/null; then
        log_error "Persistence not mounted: $UDOS_PERSIST"
        log_error "Run: udos-persist mount"
        return 1
    fi

    # Create log directory if needed
    mkdir -p "$UDOS_LOG" \
        "$UDOS_PERSIST/etc/udos" \
        "$UDOS_PERSIST/var/ui" \
        "$UDOS_PERSIST/var/ui/config" \
        "$UDOS_PERSIST/var/ui/cache" \
        "$UDOS_PERSIST/var/ui/data" \
        "$UDOS_PERSIST/var/ui/state"

    mkdir -p /etc/udos /var/log/udos /var/udos/ui

    ensure_bind_mount /etc/udos "$UDOS_PERSIST/etc/udos"
    ensure_bind_mount /var/log/udos "$UDOS_LOG"
    ensure_bind_mount /var/udos/ui "$UDOS_PERSIST/var/ui"

    log_info "Persistence verified at $UDOS_PERSIST"
    return 0
}

# Setup XDG runtime directory
setup_xdg_runtime() {
    if [ ! -d "$XDG_RUNTIME_DIR" ]; then
        log_info "Creating XDG_RUNTIME_DIR: $XDG_RUNTIME_DIR"
        mkdir -p "$XDG_RUNTIME_DIR"
        chmod 0700 "$XDG_RUNTIME_DIR"
    fi

    # Export for child processes
    export XDG_RUNTIME_DIR
    log_info "XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
}

# Check graphics stack availability
check_graphics() {
    log_info "Checking graphics stack..."

    # Check for DRI drivers
    if ! find /usr/lib/dri -name "*.so" 2>/dev/null | grep -q .; then
        log_error "No DRI drivers found. Install mesa or appropriate GPU drivers."
        return 1
    fi

    # Check for Wayland libraries
    if ! ldconfig -p | grep -q "libwayland"; then
        log_error "Wayland libraries not found. Run: apk add wayland"
        return 1
    fi

    log_info "Graphics stack available"
    return 0
}

# Ensure seatd is running
ensure_seatd() {
    log_info "Checking seatd service..."

    # Check if seatd is running
    if ! pgrep -x seatd >/dev/null 2>&1; then
        log_info "Starting seatd..."
        if ! rc-service seatd start 2>/dev/null; then
            log_warn "Failed to start seatd via OpenRC, attempting direct launch..."
            seatd -u seat &
            sleep 1
        fi
    fi

    if pgrep -x seatd >/dev/null 2>&1; then
        log_info "seatd is running"
        return 0
    else
        log_error "Failed to start seatd"
        return 1
    fi
}

# Verify udos-ui exists and is executable
check_udos_ui() {
    if [ ! -f "$UDOS_UI_BIN" ]; then
        log_error "udos-ui binary not found: $UDOS_UI_BIN"
        log_error "Build uDOS Tauri app and place at $UDOS_UI_BIN"
        return 1
    fi

    if [ ! -x "$UDOS_UI_BIN" ]; then
        log_error "udos-ui is not executable: $UDOS_UI_BIN"
        chmod +x "$UDOS_UI_BIN"
        log_info "Made executable: $UDOS_UI_BIN"
    fi

    log_info "udos-ui available at $UDOS_UI_BIN"
    return 0
}

# Setup Wayland environment
setup_wayland_env() {
    log_info "Setting up Wayland environment..."

    # Essential Wayland variables
    export WAYLAND_DISPLAY="$WAYLAND_DISPLAY"
    export XDG_SESSION_TYPE=wayland
    export LIBGL_DRIVERS_PATH=/usr/lib/dri
    export UDOS_UI_STATE="$UDOS_UI_STATE"
    export XDG_CONFIG_HOME="$UDOS_UI_STATE/config"
    export XDG_CACHE_HOME="$UDOS_UI_STATE/cache"
    export XDG_DATA_HOME="$UDOS_UI_STATE/data"
    export XDG_STATE_HOME="$UDOS_UI_STATE/state"

    # Tauri/WebKitGTK specific
    export GDK_SCALE=1
    export GDK_DPI_SCALE=1

    log_info "Wayland environment configured"
}

# Start Cage with udos-ui
start_gui_session() {
    log_info "Starting GUI session (Cage + udos-ui)..."

    # Ensure everything is ready
    ensure_persistence || return 1
    check_graphics || return 1
    ensure_seatd || return 1
    check_udos_ui || return 1
    setup_xdg_runtime
    setup_wayland_env

    log_info "Launching Cage with udos-ui..."
    log_info "User can exit by closing udos-ui window."

    # Launch Cage with udos-ui
    # cage runs as a single-app Wayland compositor
    # When udos-ui exits, cage will exit automatically
    if cage -- "$UDOS_UI_BIN"; then
        log_info "GUI session exited normally"
        log_info "Return to TTY. Restart GUI with: rc-service udos-gui start (or: udos-gui start)"
        return 0
    else
        local exit_code=$?
        log_error "GUI session exited with code: $exit_code"
        log_error "Return to TTY. Restart GUI with: rc-service udos-gui start (or: udos-gui start)"
        return $exit_code
    fi
}

# Stop GUI session
stop_gui_session() {
    log_info "Stopping GUI session..."

    # Kill cage if running
    if pgrep -x cage >/dev/null 2>&1; then
        log_info "Terminating Cage..."
        pkill -TERM cage
        sleep 2
    fi

    # Stop seatd if we started it
    if pgrep -x seatd >/dev/null 2>&1; then
        log_info "Stopping seatd..."
        rc-service seatd stop 2>/dev/null || pkill -TERM seatd
    fi

    log_info "GUI session stopped"
}

# Main entry point
main() {
    local action="${1:-start}"

    case "$action" in
        start)
            start_gui_session
            ;;
        stop)
            stop_gui_session
            ;;
        restart)
            stop_gui_session
            sleep 1
            start_gui_session
            ;;
        *)
            echo "Usage: $0 {start|stop|restart}"
            exit 1
            ;;
    esac
}

main "$@"
